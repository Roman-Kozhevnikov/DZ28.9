# DZ28.9
merge sort

Доработайте алгоритм merge sort, описанный в 11 модуле, сделав его многопоточным.
Используйте std::futurez в качестве инструмента для синхронизации результата работы потоков.
Нужно определить независимые части алгоритма, которые могут быть распараллелены и запустить 
их вычисление в отдельных потоках, как это было сделано в юните 28.7.
Потоки могут быть запущены через std::thread или std::async, но синхронизация строго через std::future. 
Также предусмотрите ограничение количества запускаемых потоков по примеру из юнита 28.7.


Задание выполнено:

- для синхронизации результата работы потоков использовано std::future

- распараллелено две независимые части алгоритма, которые вычисляются в отдельных потоках (заполнение левого и правого массивов)

- потоки запускаются через async, синхронизация через std::future

- количество запускаемых потоков ограничено через правый массив.

- стратегия derered в рекурсивной состовляющей выбрана для исключения гонки данных для m.

Программа выдаёт верные результаты. 

Комментарии оставлены для обозначения других опробованных результатов - все они рабочие.

Проблеммы:

при запуске до колличества в 10 000 и ограничении правого массива на 1 000  быестрее работает поточный вариант (скрин).

при дальнейшем увеличении количества - безпоточный вариант.

такие результаты  на данный момент мне не понятны, ноутбук 2-х ядерный 4 потока.

